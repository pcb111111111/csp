#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<iostream>
#include<string.h>
#include<vector>
#include<stack>
#include<queue>
#include<algorithm>
#include<string>
#include<map>
#include<fstream>
using namespace std;
#define _for(a,b,i) for(int i=a;i<b;i++)
/*
简易计算机；
主要步骤为：1>将前缀表达式转换为后缀表达式
            2>计算后缀表达式

*/
struct node{
    char op;
    double num;
    bool flag;//true为数字，flase为符号
};
string str;
stack<node> s;//符号栈
queue<node> q;//后缀表达式
map<char,int> op;//定义优先级
void change(){
    double num;
    node temp;
    //cout<<str;
    for(int i=0;i<str.length();){
        if(str[i] >= '0' && str[i] <= '9'){//如果是数字
            temp.flag = true;
            temp.num = str[i++] - '0';
            while(i<str.length() && str[i] >= '0' && str[i] <= '9'){//操作数不止一位
                temp.num = temp.num*10 + (str[i] - '0');
                i++;
            }
        q.push(temp);//
        }
        else//如果是操作符{
        {
            temp.flag = false;//标记是操作符
            //只要操作符栈顶元素比该操作符优先级高
            //就把操作符栈顶元素弹出到后缀表达式中
            while(!s.empty() && (op[str[i]] <= op[s.top().op])){
                q.push(s.top());
                s.pop();
            }
            temp.op = str[i];
            s.push(temp);
            i++;
        }
        //cout<<q.front().num;
    }
    //如果栈中还有操作符，就将其弹出到后缀表达式中
    while(!s.empty()){
        q.push(s.top());
        s.pop();
    }
}
double cal(){//计算后缀表达式
    double temp1,temp2;
    node cur,temp;
    while(!q.empty()){//只要后缀表达式非空
        cur = q.front();
        q.pop();
        if(cur.flag == true) s.push(cur);//操作数直接压栈
        else//如果是操作符
        {
            temp2 = s.top().num;//弹出第二操作数
            s.pop();
            temp1 = s.top().num;//弹出第一操作数
            s.pop();
            //运算
            temp.flag=true;
            if(cur.op == '+') temp.num = temp1 + temp2;
            else if(cur.op =='-') temp.num = temp1 - temp2;
            else if(cur.op =='*') temp.num = temp1 * temp2;
            else temp.num = temp1 / temp2;
            s.push(temp);
        }
    }
    return s.top().num;//为最后的值
}
int main(){
    op['+'] = 1;op['-'] = 1;//操作符优先级
    op['*'] = 2;op['/'] = 2;
    /*FILE *fp;
    if(!(fp = fopen("1.txt","r"))){
        printf("Open File Error!");
        exit(1);
    }*/
    ifstream  myfile("1.txt");
    if(!myfile.is_open()){
        printf("Open File Error!");
    }
    while(!myfile.eof()){
        getline(myfile,str);
        for(string::iterator it=str.end();it!=str.begin();it--){
            if(*it == ' ') str.erase(it);
        }
        for(string::iterator it=str.begin();it!=str.end();it++){
            if(*it == ' ') str.erase(it);//去掉所有空格
            if(*it == '/'){//删除注释
                it++;
                if(*it == '/'){
                    it--;
                    str.erase(it,str.end());
                    break;
                }
                else
                    it--;
            }


        }
       // cout<<str;
        while(!s.empty()) s.pop();//初始化栈
        change();//前缀序列转换为后缀序列
        printf("%.2f\n",cal());//计算后缀表达式
        //fclose(fp);


    }
    myfile.close();
    return 0;
}
